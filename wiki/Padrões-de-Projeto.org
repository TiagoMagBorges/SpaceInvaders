** Factory
 A classe =LoadAnimationStrategyFactory= é utilizada para criar as animações das entidades =bullet=, =enemy=, =ship=. Cada entidade informa a quantidade de sprites necessárias para a sua animação e a partir disso a Factory realiza a correta instanciação do método adequado para a geração da animação correta.
#+BEGIN_EXAMPLE
public static LoadAnimationStrategy create(String strategy){
        if(strategy.equals(MULTIPLE_FILE)){
            return MultipleFilesLoadAnimationStrategy.getInstance();
        }
        if(strategy.equals(SINGLE_FILE)){
            return SingleFileLoadAnimationStrategy.getInstance();
        }
        if(strategy.equals(ONE_IMAGE)){
            return OneImageLoadAnimationStrategy.getInstance();
        }
        return null;
    }
#+END_EXAMPLE

** Singleton
 A classe =MultipleFilesLoadAnimationStrategy= é um exemplo de como utilizamos o Singleton. Ao declarar o constructor da classe como private, nós limitamos que a leitura e criação desse sprite seja realizado apenas uma única vez pela entidade correspondente à quantidade necessárias de arquivos a serem lidos para gerar a sprite dentro do jogo. 
#+BEGIN_EXAMPLE
private static MultipleFilesLoadAnimationStrategy instance;

    private MultipleFilesLoadAnimationStrategy(){}

    public static MultipleFilesLoadAnimationStrategy getInstance(){
        if(instance == null)
            instance = new MultipleFilesLoadAnimationStrategy();
        return instance;
    }
// resto do código
#+END_EXAMPLE

** Strategy
 No nosso projeto utilizamos o Strategy para auxiliar na hora de definir qual processo mais ideal na hora de gerar as animações. Ao criar a variável =strategy= do tipo =LoadAnimationStrategy= no construtor da classe =Animation=, é possível agora decidir qual classe específica será mais adequada para gerar as animações: =OneImageLoadAnimationStrategy=, =SingleFileLoadAnimationStrategy=, =MultipleFilesLoadAnimationStrategy=. Desse modo, o código fica mais dinâmico e também mais adaptável para futuras mudanças e acréscimos. 
#+BEGIN_EXAMPLE
public class MultipleFilesLoadAnimationStrategy implements LoadAnimationStrategy{
    @Override
    public ArrayList<BufferedImage> loadAnimation(int frames, String name) {
        // resto do código
    }
}
#+END_EXAMPLE

** Observer
 No projeto, a entidade =Nave= passou a ser um =Subject= observado pelo =Observer= que é a classe =Level=. Sempre que a nave atira ela avisa o observador que agirá de acordo com as ações realizadas pelo usuário. Dessa forma, o código passa a ficar mais desacoplado e dinâmico a depender das decisões tomadas pelo usuário. 
#+BEGIN_EXAMPLE
public class Ship extends Entity implements Subject{
    public void shoot(){
        this.shoot = true;
        notifyObservers();
    }

    @Override
    public void notifyObservers() {
        for(Observer o : observers)
            o.updateObs(this.shoot);
    }
}
#+END_EXAMPLE

** Template
 Utilizamos o padrão de Template nas classes =Entity=, =Ship= e =Enemy=. Ao herdar a classe abstrata =Entity=, ambas as classes =Ship= e =Enemy= passam, apenas, a acrescentar ao "esqueleto" de suas entidades os atributos e métodos específicos de suas naturezas. Assim, o código de mantém reutilizável e de fácil compreensão. 
#+BEGIN_EXAMPLE
public abstract class Entity {
    // ...
    protected abstract void updatePosition(); // Método abstrato implementado de forma específica em subclasses
    // ...
}
#+END_EXAMPLE