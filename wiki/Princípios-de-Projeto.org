** Princípio de Responsabilidade Única
 As classes =Ship=, =Enemy= e =Bullet= utilizam o conceito de responsabilidade única ao possuírem métodos que executam funções específicas e que fazem sentido com o propósito da classe, facilitando na manutenção e na compreensão do código. 
#+BEGIN_EXAMPLE 
 // Classe Ship com responsabilidade específica para gerenciar a nave do jogador
 public class Ship extends Entity {
   // ...
   @Override
   protected void updatePosition() {
    // Atualização específica da posição da nave
   }
   // ...
 }
#+END_EXAMPLE

** Princípio Aberto/Fechado
 A forma como funciona o carregamento de animações dentro do nosso projeto se beneficia do Princípio Aberto/Fechado ao permitir a extensão de outras formas de carregamento de animações. Basta apenas criar novas classes que implementem suas particularidades, sem a necessidade de modificar nada das classes já existentes. 
#+BEGIN_EXAMPLE 
  // Classe LoadAnimationStrategyFactory permite extender o comportamento sem modificar o código existente
  public class LoadAnimationStrategy {
    // ...
    public static LoadAnimationStrategy getInstance(String strategy) {
      if (strategy.equals(MULTIPLE_FILES)) {
        if (multipleFilesStrategy == null) multipleFilesStrategy = new MultipleFilesLoadAnimationStrategy();
        return multipleFilesStrategy;
      }
      // ...
    }
  }
#+END_EXAMPLE

** Princípio de Substituição de Liskov
  As subclasses =Ship=, =Enemy= e =Bullet= possuem variações específicas mas ainda cumprem o papel herdado da superclasse =Entity= sem afetar o comportamento do sistema. Isso facilita a extensão do código e demonstra boa utilização do conceito de polimorfia. 
#+BEGIN_EXAMPLE 
  // Subclasses como Ship, Bullet e Enemy podem ser substituídas por Entity
  public abstract class Entity {
    // ...
    protected abstract void updatePosition(); // Método abstrato implementado de forma específica em subclasses
    // ...
  }
#+END_EXAMPLE